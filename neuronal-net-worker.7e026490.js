parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"eBMD":[function(require,module,exports) {
"use strict";function e(e){const t={next:e,[Symbol.iterator]:()=>t};return t}function t(t,r){return e(()=>{const e=t.next(),n=e.done,o=e.value;return{done:n,value:n?void 0:r(o)}})}Object.defineProperty(exports,"__esModule",{value:!0}),exports.produceIteratorAndIterable=e,exports.extendIterable=t;
},{}],"SvSn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NeuronalNetSimple=void 0;var e=require("./iterator-helper");const t=(e,...r)=>{if(1==r.length)return new Array(r[0]).fill(e);const n=new Array(r[0]),i=r.slice(1);for(let s=0;s<r[0];s++)n[s]=t(e,...i);return n};class r{constructor(e,r,n=1){this.inNumber=e,this.outNumber=r,this.defaultWeight=n,this.backing=t(n,e*r),Object.freeze(this)}checkRange(e,t){if(!Number.isInteger(e))throw new TypeError(t+" needs to be an integer");if(e<0)throw new RangeError(t+" needs to be greater or equal to 0");const r=this[t+"Number"];if(e>=r)throw new RangeError(t+" needs to be less than "+r)}get(e,t){return this.checkRange(e,"in"),this.checkRange(t,"out"),this.backing[this.outNumber*e+t]}set(e,t,r){return this.checkRange(e,"in"),this.checkRange(t,"out"),this.backing[this.outNumber*e+t]=r}getAsArray(){const e=new Array(this.outNumber);for(let t=0;t<this.outNumber;t++)e[t]=this.backing.slice(t*this.inNumber,(t+1)*this.inNumber);return e}setAsArray(e,r=!0){const n=t(this.defaultWeight,this.inNumber*this.outNumber);for(let t=0;t<this.outNumber;t++){const i=e[t];if(r&&!Array.isArray(i))throw new TypeError("weights["+t+"] is not an array");for(let e=0;e<this.inNumber;e++){const s=i[e];if(r&&!Number.isFinite(s))throw new Error("weights["+t+"]["+e+"] is not an number");n[t*this.outNumber+this.inNumber]=s}}this.backing=n}toJSON(){return this.getAsArray()}}class n{constructor(e,t=1,n=1){if(this.layerDefinition=e,this.learningRate=t,e.length<2)throw new RangeError("layerDefinition need to have at least two layers (input and output layer)");this.weights=new Array(e.length-1);for(let i=1;i<e.length;i++){const t=e[i-1],s=e[i],o=new r(t+1,s,n);for(let e=0;e<s;e++)o.set(0,e,-n);this.weights[i-1]=o}}getWeightsAsArray(){return this.weights.map(e=>e.getAsArray())}setWeightsAsArray(e){if(this.weights.length!=e.length)throw new RangeError("weights needs to be layerDefinition.length + 1 but was "+e.length);this.weights.forEach((t,r)=>t.setAsArray(e[r]))}applyInput(e){if(e.length!=this.layerDefinition[0])throw new RangeError("inputValues needs to be the same length as "+this.layerDefinition[0]);let t=e;for(const r of this.weights){const e=new Array(r.outNumber);for(let n=0;n<e.length;n++){let i=r.get(0,n);for(let e=1;e<r.inNumber;e++)i+=r.get(e,n)*t[e-1];e[n]=this.activationFunction(i)}t=e}return t}supervisedOnlineLearning(e){const r=t(0,e.length,e[1].length);if(this.layerDefinition.length>2)throw new RangeError("can not learn for hidden layers");for(let t=0;t<e.length;t++){const n=e[t][0],i=e[t][1],s=this.weights[0],o=this.applyInput(n);if(i.length!=o.length)throw new RangeError("expected was another length then the actual result");for(let e=0;e<o.length;e++){const h=i[e],a=o[e];if(a!=h){r[t][e]++;for(let t=0;t<s.inNumber;t++){const r=0==t?1:n[t-1],i=s.get(t,e)+this.learningRate*(h-a)*r;s.set(t,e,i)}}}}return r}trainWithDataSet(t,r=1/0){let n=void 0,i=0;return(0,e.produceIteratorAndIterable)(()=>{let e=!1;if(n)e:for(const t of n)for(const r of t)if(r>0){e=!0;break e}return n&&!e?{done:!0,value:"resolved"}:i>=r?{done:!0,value:"aborted"}:{done:!1,value:{testingResult:n=this.supervisedOnlineLearning(t),remainingTries:r-++i}}})}trainTillFinished(e,t=1/0){const r=this.trainWithDataSet(e,t);for(;;){const e=r.next();if(e.done)return e.value}}toJSON(){return this.weights.map(e=>e.toJSON())}}class i extends n{activationFunction(e){return e>=0?1:0}}exports.NeuronalNetSimple=i;
},{"./iterator-helper":"eBMD"}],"tMcB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WorkerHelper=void 0;const e=r=>{if(r instanceof Error)return{message:r.message,stack:r.stack,name:r.name};if("object"!=typeof r)return r;{const s=JSON.stringify(r,(t,s)=>s==r?s:e(s));try{return JSON.parse(s)}catch(t){return console.error("could not parse:",s,"from",r),r}}};class r{constructor(e=self){this.worker=e,this.ready=this.expectType("ready"),this.readyState=!1,this.sendControl("ready"),this.ready.then(()=>this.readyState=!0)}async waitForAnyMessage(){return await this.ready,new Promise((e,r)=>{const t=e=>{if(!e.target)throw new Error("event.target is falsy");e.target.removeEventListener("message",s),e.target.removeEventListener("messageerror",a)},s=r=>{t(r),e(r.data)},a=e=>{t(e),r(e)};this.worker.addEventListener("message",s),this.worker.addEventListener("messageerror",a)})}async expectType(e,r=!1){for(;;){const t=await this.waitForAnyMessage();if(t.type==e)return t;if(r)throw new Error("received message with type "+t.type+" which was not expected, expected was "+e)}}async waitForType(e){for(;;){const r=await this.waitForAnyMessage();if(r.type==e)return r}}sendMessage(r,t,s="normal"){if("control"!=s&&!this.readyState)throw new Error("you can not send a message till this.ready resolved");this.worker.postMessage({channel:s,type:r,payload:e(t),timestamp:Date.now()})}sendError(e,r){this.sendMessage(e,r,"error")}sendControl(e){this.sendMessage(e,void 0,"control")}}exports.WorkerHelper=r;
},{}],"vHqw":[function(require,module,exports) {
"use strict";var e=require("./neuronal-net-helper"),a=require("./worker-helper");const r=new a.WorkerHelper;(async()=>{await r.ready;const a=await r.waitForType("create"),{neuronalNet:t,layerDefinition:n}=a.payload;if("NeuronalNetSimple"!=t)throw new Error("do not have the requested net "+t);const i=new e.NeuronalNetSimple(n);(async()=>{for(;;){const e=await r.waitForType("train-set"),{trainingsSet:a,allowedTries:t=1/0}=e.payload,n=i.trainWithDataSet(a,t);for(;;){const e=n.next();if(e.done){r.sendMessage("training-finished",{trainingResult:e.value});break}r.sendMessage("training-progressed",{intermediateResult:e.value})}}})(),(async()=>{for(;;){const e=await r.waitForType("evaluate-value"),{input:a}=e.payload,t=i.applyInput(a);r.sendMessage("evaluate-result",{result:t})}})()})().catch(e=>r.sendError("uncaught-error",e));
},{"./neuronal-net-helper":"SvSn","./worker-helper":"tMcB"}]},{},["vHqw"], null)